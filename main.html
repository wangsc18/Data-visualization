<!DOCTYPE html>
<html>
<head>
    <title>pca</title>
    <script src="d3.min.js"></script>
    <script src="d3-v6-tip.js"></script>
    <link rel="stylesheet" href="d3-tip.css">
</head>

<body>
    <style>
    #toggleDragMode {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
    }
    </style>
    <button id="toggleDragMode">Toggle Drag Mode</button>
    <script>
    (function() {
        var width = 1200, height = 1200;
        var canvas = d3.select('body').append('canvas').attr('width', width).attr('height', height);
        var gl = canvas.node().getContext('webgl');

        var rotation = [0, 0];
        var scale = 1.0;
        var dragMode = false;

        document.getElementById('toggleDragMode').addEventListener('click', function() {
            dragMode = !dragMode;
            document.body.style.cursor = dragMode ? 'grab' : 'auto';
        });

        var drag = d3.drag()
            .on('drag', function(event) {
                if (!dragMode) {
                    return;
                }

                var dx = event.dx / width * 60,
                    dy = event.dy / height * 60;
                rotation[0] += dx;
                rotation[1] += dy;
                draw();
            });
        
        canvas.call(drag);
        canvas.call(drag);

        canvas.on('wheel', function(event) {
            // 更新缩放因子
            scale += event.deltaY * -0.001;
            scale = Math.min(Math.max(.125, scale), 4);
            draw();
        });

        var vertexShaderSource = `
            attribute vec3 position;
            attribute vec3 color;
            varying vec3 vColor;
            uniform mat4 rotationMatrix;
            uniform float scale;
            void main() {
                gl_Position = rotationMatrix * vec4(scale * position, 1.0);
                gl_PointSize = 8.0;
                vColor = color;
            }
        `;

        var fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor;
            void main() {
                float r = 0.0, delta = 0.0, alpha = 1.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
                if (r > 1.0) {
                    discard;
                }
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
            return;
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
            return;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR linking program!', gl.getProgramInfoLog(program));
            return;
        }

        gl.useProgram(program);

        var positionLocation = gl.getAttribLocation(program, 'position');
        var colorLocation = gl.getAttribLocation(program, 'color');
        var rotationMatrixLocation = gl.getUniformLocation(program, 'rotationMatrix');

        var positionBuffer = gl.createBuffer();
        var colorBuffer = gl.createBuffer();

        var positions, colors;

        d3.csv('pca_data.csv').then(function(data) {
            var colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            positions = new Float32Array(data.length * 3);
            colors = new Float32Array(data.length * 3);
            data.forEach(function(d, i) {
                positions[i * 3] = +d['Dimension 1'];
                positions[i * 3 + 1] = +d['Dimension 2'];
                positions[i * 3 + 2] = +d['Dimension 3'];

                var color = d3.rgb(colorScale(d.Label));
                colors[i * 3] = color.r / 255;
                colors[i * 3 + 1] = color.g / 255;
                colors[i * 3 + 2] = color.b / 255;
            });

            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

            draw();
        });

        function draw() {
            var cosTheta = Math.cos(rotation[0] / 180 * Math.PI);
            var sinTheta = Math.sin(rotation[0] / 180 * Math.PI);
            var cosPhi = Math.cos(rotation[1] / 180 * Math.PI);
            var sinPhi = Math.sin(rotation[1] / 180 * Math.PI);

            var rotationMatrix = new Float32Array([
                cosTheta, 0, sinTheta, 0,
                sinPhi * sinTheta, cosPhi, -sinPhi * cosTheta, 0,
                -cosPhi * sinTheta, sinPhi, cosPhi * cosTheta, 0,
                0, 0, 0, 1
            ]);

            gl.uniformMatrix4fv(rotationMatrixLocation, false, rotationMatrix);
            gl.uniform1f(gl.getUniformLocation(program, 'scale'), scale);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, positions.length / 3);
        }
    })();
    </script>
</body>

</html>