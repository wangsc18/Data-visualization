<!DOCTYPE html>
<html>
<head>
    <title>pca</title>
    <script src="d3.min.js"></script>
    <script src="d3-v6-tip.js"></script>
    <script src="https://d3js.org/d3-chord.v1.min.js"></script>

    <link rel="stylesheet" href="d3-tip.css">
    <style>
        .chord path {
          fill-opacity: .67;
          stroke: #000;
          stroke-width: .5px;
        }
    </style>
</head>

<body>
    <style>
    #toggleDragMode {
        position: absolute;
        top: 100px;
        left: 100px;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        z-index: 1000;
    }
    .canvas-container {
        display: flex;
    }
    .tooltip {
        position: absolute;
        background-color: white;
        color: black;
        padding: 5px;
        border: 1px solid black;
    }
    </style>
    <button id="toggleDragMode">Toggle Drag Mode</button>
    <div id="canvasContainer" class="canvas-container">
        <div class="graph columns eight"></div>
    </div>
    <script>
    (function() {
        var width = 1200, height = 1200;
        var width1 = 1200, height1 = 1200;
        var width2 = 100, height2 = 100;
        var container = d3.select('body').append('div').attr('class', 'canvas-container');
        var canvas1 = container.append('canvas').attr('width', width).attr('height', height);
        var canvas2 = container.append('svg').attr('width', width1).attr('height', height1);
        var gl = canvas1.node().getContext('webgl');


        // 设置视口
        var rotation = [0, 0];
        var scale = 1.0;
        var dragMode = false;

        // 设置透明度
        var scatter_alpha = 0.5;
        var sphere_alpha = 0.5;

        // 选中的球体列表
        var selectedSpheres = [];

        // 设置原点坐标
        var movex = 400;
        var movey = 600;

        // 创建x、y和z轴的比例尺
        var xScale = d3.scaleLinear().domain([0, 1]).range([0,400]);
        var yScale = d3.scaleLinear().domain([0, 1]).range([400, 0]);
        var zScale = d3.scaleLinear().domain([0, 1]).range([0, 300]);

        var canvas2rect = [];
        var canvas2recttext = [];
        var axis = [];

        var points_3D = [];
        var points_2D = [];
        var points_1D = [];
        var chord_attr = []

        var points_x = [];
        var points_y = [];
        var points_z = [];
        var file_list_x = [];
        var file_list_y = [];
        var file_list_z = [];
        var x_index = -1;
        var y_index = -1;
        var z_index = -1;
        var forth_index = -1;

        var initial_points = [];
        var maxIndices = [];
        var filename = []

        // 读取最原始的数据
        d3.csv("CowenKeltnerEmotionalVideos.csv").then(function(data) {
            data.forEach(function(d) {
                let row = [];
                Object.keys(d).forEach(function(key) {
                    row.push(d[key]);
                });
                // 将第一列作为文件名
                filename.push(row[0]);
                // 去除第一列并将其他内容转换为浮点数
                row = row.slice(1).map(function(item) {
                    return parseFloat(item);
                });
                initial_points.push(row);
            });

            // 计算每个点的最大值的索引，作为类别
            maxIndices = initial_points.map(function(row) {
                let max = Math.max.apply(null, row);
                return row.indexOf(max);
            });
        })
        // console.log(initial_points);

        function print_1D(index1)
        {
          show_points = [];
          file_list_x = [];
            for (let i = 0;i<maxIndices.length;i++){
                if (maxIndices[i] == index1){
                    show_points.push(initial_points[i]);
                    file_list_x.push(filename[i]);
                }
            }
            
            let newShowPoints = show_points.map(function(row) {
                    return [row[index1]];
                });
            // console.log(newShowPoints);

            // 创建x轴
            let xAxis = d3.axisBottom(xScale);
            let xAxisG = canvas2.append("g")
                .attr("transform", "translate(" + movex.toString() + "," + movey.toString() + ") rotate(0)")
                .call(xAxis);
            let xAxisText = canvas2.append("text")
                .attr("transform", "translate(" + (movex + 420).toString() + "," + movey.toString() + ")")
                .text(sphere_emotion[index1].toString());
            axis.push([xAxisG, xAxisText]);

            if (points_y.length > 0) {
                // 说明从2D切换到1D
                // console.log(points_y);

                if (index1 == x_index){
                    // 说明留下了x轴
                    for (let i = 0; i < points_y.length; i++) {
                        points_y[i].remove();
                    }
                    // console.log(points_x.length);
                    // console.log(newShowPoints.length);
                    for (let i = 0; i < points_x.length; i++) {
                        points_x[i].transition()
                            .duration(1000)
                            .attr('cx', xScale(newShowPoints[i][0]) + movex)
                            .attr('cy', movey)
                            .attr('r', 5)
                            .attr('fill', d3.rgb(sphere_colors[index1 * 3] * 255, sphere_colors[index1 * 3 + 1] * 255, sphere_colors[index1 * 3 + 2] * 255))
                            .attr('fill-opacity', (newShowPoints[i][0]));
                    }
                    points_y = [];
                    y_index = -1;
                }
                else {
                    // 说明留下了y轴
                    for (let i = 0; i < points_x.length; i++) {
                        points_x[i].remove();
                    }
                    // console.log(points_y.length);
                    // console.log(newShowPoints.length);
                    for (let i = 0; i < points_y.length; i++) {
                        points_y[i].transition()
                            .duration(500)
                            .attr('cx', movex)
                            .attr('cy', movey)
                            .attr('r', 5)
                            .attr('fill', d3.rgb(sphere_colors[index1 * 3] * 255, sphere_colors[index1 * 3 + 1] * 255, sphere_colors[index1 * 3 + 2] * 255))
                            .attr('fill-opacity', (newShowPoints[i][0]));
                        points_y[i].transition()
                            .delay(500)
                            .duration(500)
                            .attr('cx', xScale(newShowPoints[i][0]) + movex)
                            .attr('cy', movey)
                            .attr('r', 5)
                            .attr('fill', d3.rgb(sphere_colors[index1 * 3] * 255, sphere_colors[index1 * 3 + 1] * 255, sphere_colors[index1 * 3 + 2] * 255))
                            .attr('fill-opacity', (newShowPoints[i][0]));
                    }
                    points_x = points_y;
                    points_y = [];
                    x_index = index1;
                    y_index = -1;
                }
            }
            else {
                // 说明是第一次绘制1D
                for(let i = 0; i < newShowPoints.length; i++) {
                    let circle = canvas2.append('circle')
                        .attr('cx', xScale(newShowPoints[i][0]) + movex)
                        .attr('cy', movey)
                        .attr('r', 5)
                        .attr('fill', d3.rgb(sphere_colors[index1 * 3] * 255, sphere_colors[index1 * 3 + 1] * 255, sphere_colors[index1 * 3 + 2] * 255))
                        .attr('fill-opacity', (newShowPoints[i][0]));

                    points_x.push(circle);
                }
                x_index = index1;
            }
        }

        function print_2D(index1, index2)
        {
            show_points_x = [];
            show_points_y = [];
            file_list_x = [];
            file_list_y = [];
            show_points = [];

            for (let i = 0; i<maxIndices.length;i++){
                if (maxIndices[i] == index1){
                    show_points_x.push(initial_points[i]);
                    file_list_x.push(filename[i]);
                }
                if (maxIndices[i] == index2){
                    show_points_y.push(initial_points[i]);
                    file_list_y.push(filename[i]);
                }
                if (maxIndices[i] == index1 | maxIndices[i] == index2){
                    show_points.push(initial_points[i]);
                }
            }

            // console.log(show_points);
            let newShowPointsx = show_points_x.map(function(row) {
                    return [row[index1],row[index2]];
                });
            let newShowPointsy = show_points_y.map(function(row) {
                    return [row[index1],row[index2]];
                });

            // console.log(newShowPoints);

            // 创建x轴
            let xAxis = d3.axisBottom(xScale);
            let xAxisG = canvas2.append("g")
                .attr("transform", "translate(" + movex.toString() + "," + movey.toString() + ") rotate(0)")
                .call(xAxis);
            let xAxisText = canvas2.append("text")
                .attr("transform", "translate(" + (movex + 420).toString() + "," + movey.toString() + ")")
                .text(sphere_emotion[index1].toString());
            axis.push([xAxisG, xAxisText]);

            // 创建y轴
            let yAxis = d3.axisLeft(yScale);
            let yAxisG = canvas2.append("g")
                .attr("transform",  "translate(" + movex.toString() + "," + (movey - movex).toString() + ") rotate(0)")
                .call(yAxis);
            let yAxisText = canvas2.append("text")
                .attr("transform", "translate(" + movex.toString() + "," + (movey - movex - 20).toString() + ")")
                .text(sphere_emotion[index2].toString());
            axis.push([yAxisG, yAxisText]);

            if (points_z.length > 0){
                // 说明从3D切换到2D
                // 找到x_index、y_index、z_index中哪个不在index1，index2中，剩下按顺序分配xy轴
                if (x_index == index1) {
                    // 保留points_x，将x移回去
                    for(let i = 0; i < newShowPointsx.length; i++)
                    {
                        let color_print = [];
                        color_print.push((sphere_colors[index1 * 3] * newShowPointsx[i][0] + sphere_colors[index2 * 3] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        
                        points_x[i].transition()
                            .duration(1000)
                            .attr('cx', xScale(newShowPointsx[i][0]) + movex)
                            .attr('cy', yScale(newShowPointsx[i][1]) + movey - movex)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                    }
                    if (y_index == index2){
                        // 保留points_y，删除points_z，将y移回去
                        for (let i = 0; i < newShowPointsy.length; i++) {
                            let color_print = [];
                            color_print.push((sphere_colors[index1 * 3] * newShowPointsy[i][0] + sphere_colors[index2 * 3] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            
                            points_y[i].transition()
                                .duration(1000)
                                .attr('cx', xScale(newShowPointsy[i][0]) + movex)
                                .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                                .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                                .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                        }
                        for (let i = 0; i < points_z.length; i++) {
                            points_z[i].remove();
                        }
                    }
                    else{
                        // 保留points_x，将x移回去
                        for(let i = 0; i < newShowPointsx.length; i++)
                        {
                            let color_print = [];
                            color_print.push((sphere_colors[index1 * 3] * newShowPointsx[i][0] + sphere_colors[index2 * 3] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                            
                            points_x[i].transition()
                                .duration(1000)
                                .attr('cx', xScale(newShowPointsx[i][0]) + movex)
                                .attr('cy', yScale(newShowPointsx[i][1]) + movey - movex)
                                .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                                .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                        }
                        // 保留points_z，删除points_y，将z移至y
                        for (let i = 0; i < points_y.length; i++) {
                            points_y[i].remove();
                        }
                        for (let i = 0; i < newShowPointsy.length; i++) {
                            let color_print = [];
                            color_print.push((sphere_colors[index1 * 3] * newShowPointsy[i][0] + sphere_colors[index2 * 3] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                            
                            // 移回圆点，移动到y轴
                            points_z[i].transition()
                                .duration(500)
                                .attr('cx', movex)
                                .attr('cy', movey)
                                .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                                .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                            points_z[i].transition()
                                .delay(500)
                                .duration(500)
                                .attr('cx', movex)
                                .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                                .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                                .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                            
                            points_z[i].transition()
                                .delay(1000)
                                .duration(500)
                                .attr('cx', xScale(newShowPointsy[i][0]) + movex)
                                .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                                .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                                .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                        }
                        points_y = points_z;
                        y_index = index2;
                    }
                }
                else{
                    // 删除points_x，将yz移至xy
                    for (let i = 0; i < points_x.length; i++) {
                        points_x[i].remove();
                    }
                    for (let i = 0; i < newShowPointsx.length; i++) {
                        let color_print = [];
                        color_print.push((sphere_colors[index1 * 3] * newShowPointsx[i][0] + sphere_colors[index2 * 3] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                        
                        points_y[i].transition()
                            .duration(500)
                            .attr('cx', movex)
                            .attr('cy', movey)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                        points_y[i].transition()
                            .delay(500)
                            .duration(500)
                            .attr('cx', xScale(newShowPointsx[i][0]) + movex)
                            .attr('cy', movey)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                        
                        points_y[i].transition()
                            .delay(1000)
                            .duration(500)
                            .attr('cx', xScale(newShowPointsx[i][0]) + movex)
                            .attr('cy', yScale(newShowPointsx[i][1]) + movey - movex)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                    }
                    points_x = points_y;

                    for (let i = 0; i < newShowPointsy.length; i++){
                        let color_print = [];
                        color_print.push((sphere_colors[index1 * 3] * newShowPointsy[i][0] + sphere_colors[index2 * 3] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                        color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                        
                        points_z[i].transition()
                            .duration(500)
                            .attr('cx', movex)
                            .attr('cy', movey)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                        points_z[i].transition()
                            .delay(500)
                            .duration(500)
                            .attr('cx', movex)
                            .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);

                        points_z[i].transition()
                            .delay(1000)
                            .duration(500)
                            .attr('cx', xScale(newShowPointsy[i][0]) + movex)
                            .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                            .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                            .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);
                    
                    }
                    points_y = points_z;
                    points_z = [];
                    x_index = index1;
                    y_index = index2;
                }
                
                points_z = [];
                z_index = -1;
            }
            else{
                // 说明是第一次绘制2D
                for(let i = 0;i < newShowPointsx.length;i++)
                {
                    let color_print = [];
                    color_print.push((sphere_colors[index1 * 3] * newShowPointsx[i][0] + sphere_colors[index2 * 3] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                    color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                    color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsx[i][1])/(newShowPointsx[i][0] + newShowPointsx[i][1]));
                    
                    points_x[i].transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsx[i][0]) + movex)
                        .attr('cy', yScale(newShowPointsx[i][1]) + movey - movex)
                        .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                        .attr('fill-opacity', (newShowPointsx[i][0] + newShowPointsx[i][1]) / 2);
                }
                x_index = index1;
                
                for(let i = 0; i < newShowPointsy.length;i++)
                {
                    let color_print = [];
                    color_print.push((sphere_colors[index1 * 3] * newShowPointsy[i][0] + sphere_colors[index2 * 3] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                    color_print.push((sphere_colors[index1 * 3 + 1] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 1] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                    color_print.push((sphere_colors[index1 * 3 + 2] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + 2] * newShowPointsy[i][1])/(newShowPointsy[i][0] + newShowPointsy[i][1]));
                    
                    let circle = canvas2.append('circle')
                        .attr('cx', movex)
                        .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex)
                        .attr('r', 5)
                        .attr('fill', d3.rgb(sphere_colors[index2 * 3] * 255, sphere_colors[index2 * 3 + 1] * 255, sphere_colors[index2 * 3 + 2] * 255))
                        .attr('fill-opacity', (newShowPointsy[i][1]));
                    
                    circle.transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsy[i][0]) + movex)
                        .attr('fill',d3.rgb(color_print[0] * 255, color_print[1] * 255, color_print[2] * 255))
                        .attr('fill-opacity', (newShowPointsy[i][0] + newShowPointsy[i][1]) / 2);

                    points_y.push(circle);

                }
                y_index = index2;
            }
            
            
        }
        
        function print_3D(index1,index2,index3)
        {
            show_points = [];
            show_points_x = [];
            show_points_y = [];
            show_points_z = [];
            file_list_x = [];
            file_list_y = [];
            file_list_z = [];

            for (let i = 0;i<maxIndices.length;i++){
                if (maxIndices[i] == index1){
                    show_points_x.push(initial_points[i]);
                    file_list_x.push(filename[i]);
                }
                if (maxIndices[i] == index2){
                    show_points_y.push(initial_points[i]);
                    file_list_y.push(filename[i]);
                }
                if (maxIndices[i] == index3){
                    show_points_z.push(initial_points[i]);
                    file_list_z.push(filename[i]);
                }
                if (maxIndices[i] == index1 | maxIndices[i] == index2 | maxIndices[i] == index3){
                    show_points.push(initial_points[i]);
                }
            }

            // console.log(show_points);
            
            let newShowPoints = show_points.map(function(row) {
                    return [row[index1], row[index2], row[index3]];
                });
            let newShowPointsx = show_points_x.map(function(row) {
                    return [row[index1], row[index2], row[index3]];
                });
            let newShowPointsy = show_points_y.map(function(row) {
                    return [row[index1], row[index2], row[index3]];
                });
            let newShowPointsz = show_points_z.map(function(row) {
                    return [row[index1], row[index2], row[index3]];
                });

            // console.log(newShowPoints);

            // 创建x轴
            let xAxis = d3.axisBottom(xScale);
            let xAxisG = canvas2.append("g")
                .attr("transform", "translate(" + movex.toString() + "," + movey.toString() + ") rotate(0)")
                .call(xAxis);
            let xAxisText = canvas2.append("text")
                .attr("transform", "translate(" + (movex + 420).toString() + "," + movey.toString() + ")")
                .text(sphere_emotion[index1].toString());
            axis.push([xAxisG, xAxisText]);

            // 创建y轴
            let yAxis = d3.axisLeft(yScale);
            let yAxisG = canvas2.append("g")
                .attr("transform",  "translate(" + movex.toString() + "," + (movey - movex).toString() + ") rotate(0)")
                .call(yAxis);
            let yAxisText = canvas2.append("text")
                .attr("transform", "translate(" + movex.toString() + "," + (movey - movex - 20).toString() + ")")
                .text(sphere_emotion[index2].toString());
            axis.push([yAxisG, yAxisText]);

            // 创建z轴
            let zAxis = d3.axisRight(zScale);
            let zAxisG = canvas2.append("g")
                .attr("transform",  "translate(" + movex.toString() + "," + movey.toString() + ") rotate(45)")
                .call(zAxis);
            let zAxisText = canvas2.append("text")
                .attr("transform", "translate(" + (movex - 250).toString() + "," + (movey + 250).toString() + ")")
                .text(sphere_emotion[index3].toString());
            axis.push([zAxisG, zAxisText]);

            let theta = Math.PI / 4; // 旋转角度，可以根据需要调整

            if (forth_index == -1){
                // 从2D升到3D
                for (let i = 0; i<newShowPointsx.length; i++)
                {
                    let color_print_2D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsx[i][0] + newShowPointsx[i][1];
                        total_color = sphere_colors[index1 *3 + j] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsx[i][1];   
                        color_print_2D.push(total_color / total_pos);
                    }

                    let color_print_3D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsx[i][0] + newShowPointsx[i][1] + newShowPointsx[i][2];
                        total_color = sphere_colors[index1 *3 + j] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsx[i][1] + sphere_colors[index3 * 3 + j] * newShowPointsx[i][2];   
                        color_print_3D.push(total_color / total_pos);
                    }
                    
                    points_x[i].transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsx[i][0]) - zScale(newShowPointsx[i][2]) * 0.5 * Math.sqrt(2) + movex)
                        .attr('cy', yScale(newShowPointsx[i][1]) + movey - movex + zScale(newShowPointsx[i][2]) * 0.5 * Math.sqrt(2))
                        .attr('fill',d3.rgb(color_print_3D[0] * 255, color_print_3D[1] * 255, color_print_3D[2] * 255))
                        .attr('fill-opacity', ((newShowPointsx[i][0] + newShowPointsx[i][1] + newShowPointsx[i][2]) / 3))

                }
                x_index = index1;
                
                for(let i = 0; i<newShowPointsy.length; i++)
                {
                    let color_print_2D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsy[i][0] + newShowPointsy[i][1];
                        total_color = sphere_colors[index1 * 3 + j] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsy[i][1];   
                        color_print_2D.push(total_color / total_pos);
                    }
                    let color_print_3D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsy[i][0] + newShowPointsy[i][1] + newShowPointsy[i][2];
                        total_color = sphere_colors[index1 * 3 + j] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsy[i][1] + sphere_colors[index3 * 3 + j] * newShowPointsy[i][2];   
                        color_print_3D.push(total_color / total_pos);
                    }
                    
                    points_y[i].transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsy[i][0]) - zScale(newShowPointsy[i][2]) * 0.5 * Math.sqrt(2) + movex)
                        .attr('cy', yScale(newShowPointsy[i][1]) + movey - movex + zScale(newShowPointsy[i][2] * 0.5 * Math.sqrt(2)))
                        .attr('fill',d3.rgb(color_print_3D[0] * 255, color_print_3D[1] * 255, color_print_3D[2] * 255))
                        .attr('fill-opacity', ((newShowPointsy[i][0] + newShowPointsy[i][1] + newShowPointsy[i][2]) / 3))
                    
                }
                y_index = index2;

            }
            else{
                // 从4类降到3类
                for(let i=0; i<newShowPointsx.length; i++)
                {
                    let color_print_3D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsx[i][0] + newShowPointsx[i][1] + newShowPointsx[i][2];
                        total_color = sphere_colors[index1 *3 + j] * newShowPointsx[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsx[i][1] + sphere_colors[index3 * 3 + j] * newShowPointsx[i][2];   
                        color_print_3D.push(total_color / total_pos);
                    }

                    let circle = canvas2.append('circle')
                        .attr('cx', movex - zScale(newShowPointsx[i][2] * 0.5 * Math.sqrt(2)))
                        .attr('cy', movey + zScale(newShowPointsx[i][2] * 0.5 * Math.sqrt(2)))
                        .attr('r', 5)
                        .attr('fill', d3.rgb(sphere_colors[index3 * 3] * 255, sphere_colors[index3 * 3 + 1] * 255, sphere_colors[index3 * 3 + 2] * 255))
                        .attr('fill-opacity', ((newShowPointsx[i][2])));
                    
                    circle.transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsx[i][0]) - zScale(newShowPointsx[i][2]) * 0.5 * Math.sqrt(2) + movex)
                        .attr('cy', movey - movex + yScale(newShowPointsx[i][1]) + zScale(newShowPointsx[i][2]) * 0.5 * Math.sqrt(2))
                        .attr('fill',d3.rgb(color_print_3D[0] * 255, color_print_3D[1] * 255, color_print_3D[2] * 255))
                        .attr('fill-opacity', ((newShowPointsx[i][0] + newShowPointsx[i][1] + newShowPointsx[i][2]) / 3))
                    
                    points_x.push(circle);
                }
                x_index = index1;

                for(let i=0; i<newShowPointsy.length; i++)
                {
                    let color_print_3D = [];
                    for (let j = 0; j < 3; j++) {
                        total_pos = newShowPointsy[i][0] + newShowPointsy[i][1] + newShowPointsy[i][2];
                        total_color = sphere_colors[index1 *3 + j] * newShowPointsy[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsy[i][1] + sphere_colors[index3 * 3 + j] * newShowPointsy[i][2];   
                        color_print_3D.push(total_color / total_pos);
                    }

                    let circle = canvas2.append('circle')
                        .attr('cx', movex - zScale(newShowPointsy[i][2] * 0.5 * Math.sqrt(2)))
                        .attr('cy', movey + zScale(newShowPointsy[i][2] * 0.5 * Math.sqrt(2)))
                        .attr('r', 5)
                        .attr('fill', d3.rgb(sphere_colors[index3 * 3] * 255, sphere_colors[index3 * 3 + 1] * 255, sphere_colors[index3 * 3 + 2] * 255))
                        .attr('fill-opacity', ((newShowPointsy[i][2])));
                    
                    circle.transition()
                        .duration(1000)
                        .attr('cx', xScale(newShowPointsy[i][0]) - zScale(newShowPointsy[i][2]) * 0.5 * Math.sqrt(2) + movex)
                        .attr('cy', movey - movex + yScale(newShowPointsy[i][1]) + zScale(newShowPointsy[i][2]) * 0.5 * Math.sqrt(2))
                        .attr('fill',d3.rgb(color_print_3D[0] * 255, color_print_3D[1] * 255, color_print_3D[2] * 255))
                        .attr('fill-opacity', ((newShowPointsy[i][0] + newShowPointsy[i][1] + newShowPointsy[i][2]) / 3))
                    
                    points_y.push(circle);
                }
                y_index = index2;
                
                forth_index = -1;
            }

            for(let i=0; i<newShowPointsz.length; i++)
            {
                let color_print_3D = [];
                for (let j = 0; j < 3; j++) {
                    total_pos = newShowPointsz[i][0] + newShowPointsz[i][1] + newShowPointsz[i][2];
                    total_color = sphere_colors[index1 *3 + j] * newShowPointsz[i][0] + sphere_colors[index2 * 3 + j] * newShowPointsz[i][1] + sphere_colors[index3 * 3 + j] * newShowPointsz[i][2];   
                    color_print_3D.push(total_color / total_pos);
                }

                let circle = canvas2.append('circle')
                    .attr('cx', movex - zScale(newShowPointsz[i][2] * 0.5 * Math.sqrt(2)))
                    .attr('cy', movey + zScale(newShowPointsz[i][2] * 0.5 * Math.sqrt(2)))
                    .attr('r', 5)
                    .attr('fill', d3.rgb(sphere_colors[index3 * 3] * 255, sphere_colors[index3 * 3 + 1] * 255, sphere_colors[index3 * 3 + 2] * 255))
                    .attr('fill-opacity', ((newShowPointsz[i][2])));
                
                circle.transition()
                    .duration(1000)
                    .attr('cx', xScale(newShowPointsz[i][0]) - zScale(newShowPointsz[i][2]) * 0.5 * Math.sqrt(2) + movex)
                    .attr('cy', movey - movex + yScale(newShowPointsz[i][1]) + zScale(newShowPointsz[i][2]) * 0.5 * Math.sqrt(2))
                    .attr('fill',d3.rgb(color_print_3D[0] * 255, color_print_3D[1] * 255, color_print_3D[2] * 255))
                    .attr('fill-opacity', ((newShowPointsz[i][0] + newShowPointsz[i][1] + newShowPointsz[i][2]) / 3))
                
                points_z.push(circle);
            }
            z_index = index3;
        }

        function makeObjs(data, headings) {
            var intIndex,
                objIntList = [];
          
            for (z = 0; z < headings.length; z++) { 
              intIndex = z
              var objRulesTo = [],
                objRulesFrom = [];
              for (x = 0; x < headings.length; x++) {
                objRulesTo.push(data[z][x]);
              }
              for (y = 0; y < headings.length; y++) {
                objRulesFrom.push(data[y][z]);
              }
              var objDetails = {
                index: intIndex,
                rulesTo: objRulesTo,
                rulesFrom: objRulesFrom
              };
              objIntList.push(objDetails);
            }
            return objIntList;
        }

        function dispText(divName, data) {
            divName.select("table")
            .select("tbody")
            .selectAll("tr")
            .data(data)
            .enter()
            .append("tr").style("display", function(d){ return d> 0 ? null : "none";})
            .append("td").text(function(d, i) {return headers[i];})
            divName.select("tbody").selectAll("tr").append("td").text(function(d) { return d;});
        }

        function print_chord(selectedSpheres)
        {
            d3.csv("emotion_matrix.csv").then(function(data) {
                // 将CSV文件转换为一个二维数组
                let emotionMatrix = [];
                let movex = 700;
                let movey = 600;

                for (let i = 0; i < data.length; i++) {
                    let row = [];
                    for (let key in data[i]) {
                        if (key !== "") { // 忽略空列名
                            row.push(+data[i][key]);
                        }
                    }
                    emotionMatrix.push(row);
                }
        
                // 根据selectedSpheres生成n*n的matrix
                let n = selectedSpheres.length;
                let matrix = Array.from(Array(n), () => Array(n).fill(0));               
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        let rowIndex = selectedSpheres[i];
                        let colIndex = selectedSpheres[j];
                        matrix[i][j] = emotionMatrix[rowIndex][colIndex];
                    }
                }
                console.log(matrix)
                let headers = selectedSpheres.map(index => {
                    return sphere_emotion[index];
                })
                var textLabel = d3.scaleOrdinal().range(headers);
                var objList = []
                objList = makeObjs(matrix, headers);

                let chord = d3.chord()
                    .padAngle(.1)
                    .sortSubgroups(d3.descending)

                let innerRadius = Math.min(width, height) * .25,
                    outerRadius = innerRadius * 1.1;             
                let arc = d3.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(outerRadius)

                let ribbon = d3.ribbon()
                    .radius(innerRadius);
                
                let chords = chord(matrix);

                // 移动原点到画布中心
                let chord_g = canvas2.append("g")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("transform", "translate(" + (movex).toString() + "," + (movey).toString() + ")");

                let chord_group = chord_g.append("g")
                    .selectAll("g")
                    .data(chords.groups)
                    .enter().append("g");

                var chord_svg = canvas2.append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .append("g")
                    .attr("id", "circle")
                    .attr("transform", "translate(" + (movex).toString()+ "," + (movey).toString() + ")");
                
                 chord_group.append("path")
                    .style("fill", function(d){
                        console.log(d)                        
                        return d3.rgb(sphere_colors[selectedSpheres[d.index] * 3] * 255, sphere_colors[selectedSpheres[d.index] * 3 + 1] * 255, sphere_colors[selectedSpheres[d.index] * 3 + 2] * 255)})
                    .style("stroke", function(d){return d3.rgb(sphere_colors[selectedSpheres[d.index] * 3] * 255, sphere_colors[selectedSpheres[d.index] * 3 + 1] * 255, sphere_colors[selectedSpheres[d.index] * 3 + 2] * 255)})
                    .attr("d", arc)
                    .attr("class", function(d) { return d.index; })
                    .on("mouseover.fade", fade(.1))
                    .on("mouseout.fade", fade(1))
                    .on("mouseover.par", function(event, d) {
                    d3.selectAll("tbody").selectAll("tr").remove();
                    var pars = d3.select(".inbound");
                    dispText(pars, objList[d.index].rulesFrom); 
                    })
                    .on("mouseover.par2", function(event, d) {
                        d3.select(".inbound").select("#title").text("Rules to " + headers[d.index] + " from:");
                        d3.select(".outbound").select("#title").text("Rules from " + headers[d.index] + " to:");
                        var pars = d3.select(".outbound");
                        dispText(pars, objList[d.index].rulesTo);
                    });
                
                var ticks = chord_svg.append("g").selectAll("g")
                    .data(chords.groups)
                  .enter().append("g").selectAll("g")
                    .data(groupTicks)
                  .enter().append("g")
                    .attr("transform", function(d) {
                      return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                          + "translate(" + outerRadius + ",0)";
                    });
                
                chord_svg.append("g").selectAll("text")
                        .data(chords.groups)
                    .enter()
                    .append("sgv:text")
                        .each(function(d){ d.angle = (d.startAngle + d.endAngle)/2;})
                        .attr("dy", ".35em")
                        .attr("class", "title")
                        .attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
                        .attr("transform", function(d) {
                        return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                            + "translate(" + (outerRadius + 40) + ")"
                            + (d.angle > Math.PI ? "rotate(180)" : "");
                        })
                        .text(function(d,i) {return textLabel(i+1);});
                
                ticks.append("line")
                    .attr("x1", 1)
                    .attr("y1", 0)
                    .attr("x2", 5)
                    .attr("y2", 0)
                    .style("stroke", "#000");
                
                ticks.append("text")
                    .attr("x", 8)
                    .attr("dy", ".35em")
                    .attr("transform", function(d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
                    .style("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
                    .text(function(d) { return d.label; });

                chord_svg.append("g")
                    .attr("class", "chord")
                    .selectAll("path")
                    .data(chords)
                    .enter().append("path")
                    .attr("d", ribbon)
                    .style("fill", function(d){
                        console.log(d.target.index)
                        return d3.rgb(sphere_colors[selectedSpheres[d.target.index] * 3] * 255, sphere_colors[selectedSpheres[d.target.index] * 3 + 1] * 255, sphere_colors[selectedSpheres[d.target.index] * 3 + 2] * 255)})
                    .style("opacity", 1);
                
                chord_attr.push(chord_svg)
                chord_attr.push(chord_g)

                // Returns an array of tick angles and labels, given a group.
                function groupTicks(d) {
                var k = (d.endAngle - d.startAngle) / d.value;
                return d3.range(0, d.value, 10).map(function(v, i) {
                    return {
                    angle: v * k + d.startAngle,
                    label: i % 1 || i == 0 ? null : v
                    };
                });
                }
                
                function groupName(d) {
                var k = (d.endAngle + d.startAngle) / 2;
                return k;
                }
                
                // Returns an event handler for fading a given chord group.
                function fade(opacity) {
                return function(g, i) {
                    chord_svg.selectAll(".chord path")
                        .filter(function(d) { return d.source.index != i.index && d.target.index != i.index; })
                    .transition()
                        .style("opacity", opacity);
                };
                }
            
            })    
            console.log("chord success")    
        }
            
        // 渲染右侧画布
        function drawCanvas2(addMark = false)
        {
            if (canvas2rect.length == 0)
            {
                for (let i = 0; i < points_x.length; i++) {
                    points_x[i].remove();
                }
                points_x = [];
                for (let i = 0; i < axis.length; i++) {
                    axis[i][0].remove();
                    axis[i][1].remove();
                }
                axis = [];
                // console.log(axis);

                for (let i = 0; i < chord_attr.length; i++) {
                    chord_attr[i].remove();
                }
                chord_attr = [];
            }

            if (canvas2rect.length == 1)
            {
                for (let i = 0; i < axis.length; i++) {
                    axis[i][0].remove();
                    axis[i][1].remove();
                }
                axis = [];
                print_1D(selectedSpheres[0]);
                // console.log(axis);
                for (let i = 0; i < chord_attr.length; i++) {
                    chord_attr[i].remove();
                }
                chord_attr = [];
            }

            if (canvas2rect.length == 2)
            {
                for (let i = 0; i < axis.length; i++) {
                    axis[i][0].remove();
                    axis[i][1].remove();
                }
                axis = [];
                print_2D(selectedSpheres[0],selectedSpheres[1]);
                // console.log(axis);

                for (let i = 0; i < chord_attr.length; i++) {
                    chord_attr[i].remove();
                }
                chord_attr = [];
            }

            if (canvas2rect.length == 3)
            {
                for (let i = 0; i < axis.length; i++) {
                    axis[i][0].remove();
                    axis[i][1].remove();
                }
                axis = [];
                print_3D(selectedSpheres[0],selectedSpheres[1],selectedSpheres[2]);

                for (let i = 0; i < chord_attr.length; i++) {
                    chord_attr[i].remove();
                }
                chord_attr = [];
            }

            if (canvas2rect.length > 3)
            {
                for (let i = 0; i < points_x.length; i++) {
                    points_x[i].remove();
                }
                points_x = [];
                for (let i = 0; i < points_y.length; i++) {
                    points_y[i].remove();
                }
                points_y = [];
                for (let i = 0; i < points_z.length; i++) {
                    points_z[i].remove();
                }
                points_z = [];
                for (let i = 0; i < axis.length; i++) {
                    axis[i][0].remove();
                    axis[i][1].remove();
                }
                axis = [];
                forth_index = selectedSpheres[3];

                for (let i = 0; i < chord_attr.length; i++) {
                    chord_attr[i].remove();
                }
                chord_attr = [];

                print_chord(selectedSpheres);
            }
            console.log(points_x.length, points_y.length, points_z.length);

            // 鼠标悬停时显示标签
            for(let i = 0; i < points_x.length; i++) {
                points_x[i].on("mouseover", function(d) {
                    // 创建提示框并设置其内容为对应的文件名
                    let tooltip = d3.select("body").append("div")
                        .attr("class", "tooltip")
                        .style("opacity", .9)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");

                    tooltip.append("p").text(sphere_emotion[selectedSpheres[0]] + ' ' + file_list_x[i]);

                    // 创建video元素并设置其src属性为对应的视频文件的URL
                    tooltip.append("video")
                        .attr("src", "video/" + file_list_x[i])
                        .attr("controls", "true")
                        .attr("autoplay", "true");
                })
                .on("mouseout", function(d) {
                    // 鼠标移出时移除提示框
                    d3.select(".tooltip").remove();
                });
            }
            for (let i = 0; i < points_y.length; i++) {
                points_y[i].on("mouseover", function(d) {
                    // 创建提示框并设置其内容为对应的文件名
                    let tooltip = d3.select("body").append("div")
                        .attr("class", "tooltip")
                        .style("opacity", .9)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");

                    tooltip.append("p").text(sphere_emotion[selectedSpheres[1]] + ' ' + file_list_y[i]);

                    // 创建video元素并设置其src属性为对应的视频文件的URL
                    tooltip.append("video")
                        .attr("src", "video/" + file_list_y[i])
                        .attr("controls", "true")
                        .attr("autoplay", "true");
                })
                .on("mouseout", function(d) {
                    // 鼠标移出时移除提示框
                    d3.select(".tooltip").remove();
                });
            }
            for (let i = 0; i < points_z.length; i++) {
                points_z[i].on("mouseover", function(d) {
                    // 创建提示框并设置其内容为对应的文件名
                    let tooltip = d3.select("body").append("div")
                        .attr("class", "tooltip")
                        .style("opacity", .9)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");

                    tooltip.append("p").text(sphere_emotion[selectedSpheres[2]] + ' ' + file_list_z[i]);

                    // 创建video元素并设置其src属性为对应的视频文件的URL
                    tooltip.append("video")
                        .attr("src", "video/" + file_list_z[i])
                        .attr("controls", "true")
                        .attr("autoplay", "true");
                })
                .on("mouseout", function(d) {
                    // 鼠标移出时移除提示框
                    d3.select(".tooltip").remove();
                });
            }
        }

        // 实现webgl的视角拖拽
        document.getElementById('toggleDragMode').addEventListener('click', function() {
            dragMode = !dragMode;
            document.body.style.cursor = dragMode ? 'grab' : 'auto';
        });

        var drag = d3.drag()
            .on('drag', function(event) {
                if (!dragMode) {
                    return;
                }

                var dx = event.dx / width * 60,
                    dy = event.dy / height * 60;
                rotation[0] += dx;
                rotation[1] += dy;
                draw();
            });
        
        canvas1.call(drag);
        
        // 实现鼠标滚轮缩放
        canvas1.on('wheel', function(event) {
            // 更新缩放因子
            scale += event.deltaY * -0.001;
            scale = Math.min(Math.max(.125, scale), 4);

            sphere_alpha = Math.max(0.0, Math.min(1.0, sphere_alpha + event.deltaY * 0.001));
            scatter_alpha = 1.0 - sphere_alpha;

            draw();
        });

        // 渲染左侧WebGL画布
        canvas1.node().addEventListener('click', function(e) {
            if (dragMode) {
                // 如果dragMode为true，不执行选中球体的代码
                return;
            }

            var rect = canvas1.node().getBoundingClientRect();
            var x = e.clientX - rect.left;
            var y = rect.bottom - e.clientY;
            var pixels = new Uint8Array(4);
            gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
            gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            // console.log("ReadPixels coordinates: ", x, y);
            // console.log('Selected color: ' + pixels[0] + ', ' + pixels[1] + ', ' + pixels[2]);

            // 查找与该颜色对应的球体，这个index跟csv文件中的Label是对应的
            var index = Math.round(pixels[0] * (sphere_positions.length / 3) / 255);
            // console.log('Selected sphere index: ' + index);
            // console.log('Selected sphere emotion: ' + sphere_emotion[index]);

            var selectedIndex = selectedSpheres.indexOf(index);
            if (selectedIndex === -1) {
            
                // 如果该球体没有被选中，将其添加到数组中
                selectedSpheres.push(index);
                let rectWidth = 250; // 矩形的宽度
                let rectHeight = 100; // 矩形的高度
                let rectX = 0; // 矩形的x坐标
                let rectY = selectedSpheres.length * 110;

                let color = d3.rgb(sphere_colors[index * 3] * 255, sphere_colors[index * 3 + 1] * 255, sphere_colors[index * 3 + 2] * 255);
                
                let rect = canvas2.append('rect')
                    .attr('x', rectX)
                    .attr('y', (selectedSpheres.length - 1) * 110)
                    .attr('width', rectWidth)
                    .attr('height', rectHeight)
                    .attr('fill', color)
                    .attr('fill-opacity', scatter_alpha)
                    .on('click', function() {  // 添加这行来添加点击事件
                        
                        let index_rect = canvas2rect.indexOf(rect);
                        selectedSpheres.splice(index_rect, 1);  

                        canvas2rect[index_rect].remove();
                        canvas2recttext[index_rect].remove();

                        canvas2rect.splice(index_rect, 1);
                        canvas2recttext.splice(index_rect, 1);

                        for (let i = 0; i < canvas2rect.length; i++) {
                            canvas2rect[i].attr('y', i * 110);
                            canvas2recttext[i].attr('y', i * 110 + rectHeight / 2);
                        }

                        console.log('Selected spheres: ' + selectedSpheres);
                        drawCanvas2();

                        draw();
                    });

                let text = canvas2.append('text')
                    .attr('x', rectX + rectWidth / 2)  // 修改这行来设置文本的x位置为矩形的中心
                    .attr('y', (selectedSpheres.length - 1) * 110 + 50)  // 修改这行来设置文本的y位置为矩形的中心
                    .text(sphere_emotion[index])
                    .attr('font-size', '20px')
                    .attr('fill', 'black')
                    .attr('text-anchor', 'middle')  // 添加这行来设置文本的水平对齐方式为居中
                    .attr('dominant-baseline', 'middle');  // 添加这行来设置文本的垂直对齐方式为居中

                canvas2rect.push(rect);
                canvas2recttext.push(text);
                
                drawCanvas2();



            } else {
                // 如果该球体已经被选中，从数组中移除它
                selectedSpheres.splice(selectedIndex, 1);
                // console.log("selectedIndex", selectedIndex);

                canvas2rect[selectedIndex].remove();
                canvas2recttext[selectedIndex].remove();
                canvas2rect.splice(selectedIndex, 1);
                canvas2recttext.splice(selectedIndex, 1);   
                // console.log(canvas2rect);

                

                for (let i = selectedIndex; i < canvas2rect.length; i++) {
                    canvas2rect[i].attr('y', i * 110);
                    canvas2recttext[i].attr('y', i * 110 + 50);
                    // console.log(canvas2rect[i].attr('y'));
                    // console.log(canvas2recttext[i].attr('y'));  
                }

                drawCanvas2();


            }
            console.log('Selected spheres: ' + selectedSpheres);

            // 绘制
            draw();
        });

        // 着色器
        var vertexShaderSource = `
            attribute vec3 position;
            attribute vec3 color;
            attribute float size;
            varying vec3 vColor;
            uniform mat4 rotationMatrix;
            uniform float scale;
            void main() {
                gl_Position = rotationMatrix * vec4(scale * position, 1.0);
                gl_PointSize = size * scale;
                vColor = color;
            }
        `;

        var fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor;
            uniform float uAlpha;
            void main() {
                float r = 0.0, delta = 0.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
                if (r > 1.0) {
                    discard;
                }
                gl_FragColor = vec4(vColor, uAlpha);
            }
        `;

        // 初始化着色器
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
            return;
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
            return;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR linking program!', gl.getProgramInfoLog(program));
            return;
        }

        gl.useProgram(program);

        // 所有要设置的属性都是全局的，因此只需要设置一次
        var positionLocation = gl.getAttribLocation(program, 'position');
        var colorLocation = gl.getAttribLocation(program, 'color');
        var sizeLocation = gl.getAttribLocation(program, 'size');
        var rotationMatrixLocation = gl.getUniformLocation(program, 'rotationMatrix');
        var alphaLocation = gl.getUniformLocation(program, 'uAlpha');

        var scatter_positionBuffer = gl.createBuffer();
        var scatter_colorBuffer = gl.createBuffer();
        var scatter_sizeBuffer = gl.createBuffer();

        var sphere_positionBuffer = gl.createBuffer();
        var sphere_colorBuffer = gl.createBuffer();
        var sphere_sizeBuffer = gl.createBuffer();

        // 每个渲染单元都有位置、颜色和大小属性
        var scatter_positions, scatter_colors, scatter_sizes, sphere_positions, sphere_colors, sphere_sizes, sphere_emotion, pickColors;

        // 更新的球体和散点大小和颜色
        var update_sphere_sizes, update_sphere_colors, update_scatter_sizes, update_scatter_colors;

        // 每个球体对应的散点组
        var scatter_groups;
        
        var pickColorBuffer = gl.createBuffer();

        // 用于拾取的帧缓冲区和纹理
        // 隐藏帧缓冲区只用于球体的颜色拾取，不会被显示
        var pickFramebuffer = gl.createFramebuffer();
        var pickTexture = gl.createTexture();

        gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
        gl.bindTexture(gl.TEXTURE_2D, pickTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickTexture, 0);

        // 检查帧缓冲区是否完整
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status != gl.FRAMEBUFFER_COMPLETE) {
            console.error('Framebuffer is not complete: ' + status);
        }

        // 切换回默认的帧缓冲区
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
        Promise.all([
            d3.csv('tsne_data.csv'),
            d3.csv('tsne_centers.csv')
        ]).then(function([scatterData, sphereData]) {
            var colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // 处理球体数据
            sphere_positions = new Float32Array(sphereData.length * 3);
            sphere_colors = new Float32Array(sphereData.length * 3);
            sphere_sizes = new Float32Array(sphereData.length);
            update_sphere_sizes = new Float32Array(sphereData.length);
            update_sphere_colors = new Float32Array(sphereData.length);
            sphere_emotion = new Array(sphereData.length);
            scatter_groups = new Array(sphereData.length);
            sphereData.forEach(function(d, i) {
                sphere_positions[i * 3] = +d['Dimension 1'];
                sphere_positions[i * 3 + 1] = +d['Dimension 2'];
                sphere_positions[i * 3 + 2] = +d['Dimension 3'];

                // 球体的大小由组内数量决定
                sphere_sizes[i] = +d['Size'];
                sphere_emotion[i] = d['Emotion'];
                scatter_groups[i] = [];

                var color = d3.rgb(colorScale(d.Label));
                sphere_colors[i * 3] = color.r / 255;
                sphere_colors[i * 3 + 1] = color.g / 255;
                sphere_colors[i * 3 + 2] = color.b / 255;
            });
            // console.log(sphere_colors);
            update_sphere_sizes = sphere_sizes.slice();
            update_sphere_colors = sphere_colors.slice();

            // 为每个球体分配一个唯一的用于拾取的颜色
            pickColors = new Float32Array(sphere_positions.length);
            for (var i = 0; i < sphere_positions.length / 3; i++) {
                pickColors[i * 3] = i / (sphere_positions.length / 3);
                pickColors[i * 3 + 1] = i / (sphere_positions.length / 3);
                pickColors[i * 3 + 2] = i / (sphere_positions.length / 3);
                // console.log(pickColors[i * 3], pickColors[i * 3 + 1], pickColors[i * 3 + 2]);
            }

            // 将数据绑定到缓冲区
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphere_positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_sphere_colors, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_sphere_sizes, gl.STATIC_DRAW);

            // 颜色缓冲区
            gl.bindBuffer(gl.ARRAY_BUFFER, pickColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, pickColors, gl.STATIC_DRAW);
            
            // 处理散点数据
            scatter_positions = new Float32Array(scatterData.length * 3);
            scatter_colors = new Float32Array(scatterData.length * 3);
            scatter_sizes = new Float32Array(scatterData.length);
            scatterData.forEach(function(d, i) {
                scatter_positions[i * 3] = +d['Dimension 1'];
                scatter_positions[i * 3 + 1] = +d['Dimension 2'];
                scatter_positions[i * 3 + 2] = +d['Dimension 3'];

                var color = d3.rgb(colorScale(d.Label));
                scatter_colors[i * 3] = color.r / 255;
                scatter_colors[i * 3 + 1] = color.g / 255;
                scatter_colors[i * 3 + 2] = color.b / 255;

                scatter_groups[d['Label']].push(i);
            });
            scatter_sizes.fill(5.0);  // 假设所有散点的大小都是 5.0
            update_scatter_colors = scatter_colors.slice();
            update_scatter_sizes = scatter_sizes.slice();

            // 将数据绑定到缓冲区
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, scatter_positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_scatter_colors, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_scatter_sizes, gl.STATIC_DRAW);

            // console.log(scatter_groups);

            // 绘制
            draw();
        });

        function draw() {
            // 设置视口和旋转矩阵
            var cosTheta = Math.cos(rotation[0] / 180 * Math.PI);
            var sinTheta = Math.sin(rotation[0] / 180 * Math.PI);
            var cosPhi = Math.cos(rotation[1] / 180 * Math.PI);
            var sinPhi = Math.sin(rotation[1] / 180 * Math.PI);

            var rotationMatrix = new Float32Array([
                cosTheta, 0, sinTheta, 0,
                sinPhi * sinTheta, cosPhi, -sinPhi * cosTheta, 0,
                -cosPhi * sinTheta, sinPhi, cosPhi * cosTheta, 0,
                0, 0, 0, 1
            ]);
            
            gl.uniformMatrix4fv(rotationMatrixLocation, false, rotationMatrix);
            gl.uniform1f(gl.getUniformLocation(program, 'scale'), scale);

            gl.disable(gl.BLEND);
            
            // 在隐藏的帧缓冲区中渲染球体
            gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, pickColorBuffer);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(sizeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_sizeBuffer);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, sphere_positions.length / 3);
            
            // 切换回默认的帧缓冲区
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // 在默认的帧缓冲区中渲染场景
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // 设置适当的混合模式以实现半透明效果
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // 绘制球体
            gl.uniform1f(alphaLocation, sphere_alpha);

            // 判断球体是否被选中
            for (var i = 0; i < sphere_positions.length / 3; i++) {
                if (selectedSpheres.indexOf(i) !== -1) {
                    // 如果球体被选中，则变大变亮
                    update_sphere_sizes[i] = sphere_sizes[i] + 10;
                    update_sphere_colors[i * 3] = Math.min(1.0, sphere_colors[i * 3] + 0.5);  // 增加红色分量
                    update_sphere_colors[i * 3 + 1] = Math.min(1.0, sphere_colors[i * 3 + 1] + 0.5);  // 增加绿色分量
                    update_sphere_colors[i * 3 + 2] = Math.min(1.0, sphere_colors[i * 3 + 2] + 0.5);  // 增加蓝色分量

                    // 对应的散点也变大变亮
                    scatter_groups[i].forEach(function(j) {
                        update_scatter_sizes[j] = scatter_sizes[j] + 2;
                        update_scatter_colors[j * 3] = Math.min(1.0, scatter_colors[j * 3] + 0.5);
                        update_scatter_colors[j * 3 + 1] = Math.min(1.0, scatter_colors[j * 3 + 1] + 0.5);
                        update_scatter_colors[j * 3 + 2] = Math.min(1.0, scatter_colors[j * 3 + 2] + 0.5);
                    });
                    // console.log(sphere_sizes[i], update_sphere_sizes[i]);
                } else {
                    update_sphere_sizes[i] = sphere_sizes[i];
                    update_sphere_colors[i * 3] = sphere_colors[i * 3];
                    update_sphere_colors[i * 3 + 1] = sphere_colors[i * 3 + 1];
                    update_sphere_colors[i * 3 + 2] = sphere_colors[i * 3 + 2];

                    scatter_groups[i].forEach(function(j) {
                        update_scatter_sizes[j] = scatter_sizes[j];
                        update_scatter_colors[j * 3] = scatter_colors[j * 3];
                        update_scatter_colors[j * 3 + 1] = scatter_colors[j * 3 + 1];
                        update_scatter_colors[j * 3 + 2] = scatter_colors[j * 3 + 2];
                    });
                }
            }

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_sphere_colors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(sizeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_sphere_sizes, gl.STATIC_DRAW);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, sphere_positions.length / 3);

            // 绘制散点
            gl.uniform1f(alphaLocation, scatter_alpha);
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_scatter_colors, gl.STATIC_DRAW);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(sizeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, update_scatter_sizes, gl.STATIC_DRAW);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, scatter_positions.length / 3);

        }
    })();
    </script>
</body>

</html>