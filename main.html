<!DOCTYPE html>
<html>
<head>
    <title>pca</title>
    <script src="d3.min.js"></script>
    <script src="d3-v6-tip.js"></script>
    <link rel="stylesheet" href="d3-tip.css">
</head>

<body>
    <style>
    #toggleDragMode {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        z-index: 1000;
    }
    </style>
    <button id="toggleDragMode">Toggle Drag Mode</button>
    <div id="canvasContainer"></div>
    <script>
    (function() {
        var width = 1200, height = 1200;
        var canvas = d3.select('body').append('canvas').attr('width', width).attr('height', height);
        var gl = canvas.node().getContext('webgl');

        var rotation = [0, 0];
        var scale = 1.0;
        var dragMode = false;

        var scatter_alpha = 0.5;
        var sphere_alpha = 0.5;

        document.getElementById('toggleDragMode').addEventListener('click', function() {
            dragMode = !dragMode;
            document.body.style.cursor = dragMode ? 'grab' : 'auto';
        });

        var drag = d3.drag()
            .on('drag', function(event) {
                if (!dragMode) {
                    return;
                }

                var dx = event.dx / width * 60,
                    dy = event.dy / height * 60;
                rotation[0] += dx;
                rotation[1] += dy;
                draw();
            });
        
        canvas.call(drag);
        canvas.call(drag);

        canvas.on('wheel', function(event) {
            // 更新缩放因子
            scale += event.deltaY * -0.001;
            scale = Math.min(Math.max(.125, scale), 4);

            sphere_alpha = Math.max(0.0, Math.min(1.0, sphere_alpha + event.deltaY * 0.001));
            scatter_alpha = 1.0 - sphere_alpha;

            draw();
        });

        canvas.node().addEventListener('click', function(e) {
            if (dragMode) {
                // 如果dragMode为true，不执行选中球体的代码
                return;
            }

            var rect = canvas.node().getBoundingClientRect();
            var x = e.clientX - rect.left;
            var y = rect.bottom - e.clientY;
            var pixels = new Uint8Array(4);
            gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
            gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            console.log("ReadPixels coordinates: ", x, y);

            console.log('Selected color: ' + pixels[0] + ', ' + pixels[1] + ', ' + pixels[2]);

            // 查找与该颜色对应的球体
            var index = Math.round(pixels[0] * (sphere_positions.length / 3));
            console.log('Selected sphere index: ' + index);
        });

        var vertexShaderSource = `
            attribute vec3 position;
            attribute vec3 color;
            attribute float size;
            varying vec3 vColor;
            uniform mat4 rotationMatrix;
            uniform float scale;
            void main() {
                gl_Position = rotationMatrix * vec4(scale * position, 1.0);
                gl_PointSize = size * scale;
                vColor = color;
            }
        `;

        var fragmentShaderSource = `
            precision mediump float;
            varying vec3 vColor;
            uniform float uAlpha;
            void main() {
                float r = 0.0, delta = 0.0;
                vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                r = dot(cxy, cxy);
                if (r > 1.0) {
                    discard;
                }
                gl_FragColor = vec4(vColor, uAlpha);
            }
        `;

        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(vertexShader));
            return;
        }

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(fragmentShader));
            return;
        }

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('ERROR linking program!', gl.getProgramInfoLog(program));
            return;
        }

        gl.useProgram(program);

        var positionLocation = gl.getAttribLocation(program, 'position');
        var colorLocation = gl.getAttribLocation(program, 'color');
        var sizeLocation = gl.getAttribLocation(program, 'size');
        var rotationMatrixLocation = gl.getUniformLocation(program, 'rotationMatrix');
        var alphaLocation = gl.getUniformLocation(program, 'uAlpha');

        var scatter_positionBuffer = gl.createBuffer();
        var scatter_colorBuffer = gl.createBuffer();
        var scatter_sizeBuffer = gl.createBuffer();

        var sphere_positionBuffer = gl.createBuffer();
        var sphere_colorBuffer = gl.createBuffer();
        var sphere_sizeBuffer = gl.createBuffer();

        var scatter_positions, scatter_colors, scatter_sizes, sphere_positions, sphere_colors, sphere_sizes, pickColors;
        
        var pickColorBuffer = gl.createBuffer();

        // 用于拾取的帧缓冲区和纹理
        var pickFramebuffer = gl.createFramebuffer();
        var pickTexture = gl.createTexture();

        gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
        gl.bindTexture(gl.TEXTURE_2D, pickTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickTexture, 0);

        // 检查帧缓冲区是否完整
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status != gl.FRAMEBUFFER_COMPLETE) {
            console.error('Framebuffer is not complete: ' + status);
        }

        // 切换回默认的帧缓冲区
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
        Promise.all([
            d3.csv('tsne_data.csv'),
            d3.csv('tsne_centers.csv')
        ]).then(function([scatterData, sphereData]) {
            var colorScale = d3.scaleOrdinal(d3.schemeCategory10);
            // 处理散点数据
            scatter_positions = new Float32Array(scatterData.length * 3);
            scatter_colors = new Float32Array(scatterData.length * 3);
            scatter_sizes = new Float32Array(scatterData.length);
            scatterData.forEach(function(d, i) {
                scatter_positions[i * 3] = +d['Dimension 1'];
                scatter_positions[i * 3 + 1] = +d['Dimension 2'];
                scatter_positions[i * 3 + 2] = +d['Dimension 3'];

                var color = d3.rgb(colorScale(d.Label));
                scatter_colors[i * 3] = color.r / 255;
                scatter_colors[i * 3 + 1] = color.g / 255;
                scatter_colors[i * 3 + 2] = color.b / 255;
            });

            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, scatter_positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, scatter_colors, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_sizeBuffer);
            scatter_sizes.fill(5.0);  // 假设所有散点的大小都是 5.0
            gl.bufferData(gl.ARRAY_BUFFER, scatter_sizes, gl.STATIC_DRAW);

            // 处理球体数据
            sphere_positions = new Float32Array(sphereData.length * 3);
            sphere_colors = new Float32Array(sphereData.length * 3);
            sphere_sizes = new Float32Array(sphereData.length);
            sphereData.forEach(function(d, i) {
                sphere_positions[i * 3] = +d['Dimension 1'];
                sphere_positions[i * 3 + 1] = +d['Dimension 2'];
                sphere_positions[i * 3 + 2] = +d['Dimension 3'];

                sphere_sizes[i] = +d['Size'];

                var color = d3.rgb(colorScale(d.Label));
                sphere_colors[i * 3] = color.r / 255;
                sphere_colors[i * 3 + 1] = color.g / 255;
                sphere_colors[i * 3 + 2] = color.b / 255;
            });

            // 为每个球体分配一个唯一的颜色
            pickColors = new Float32Array(sphere_positions.length);
            for (var i = 0; i < sphere_positions.length / 3; i++) {
                pickColors[i * 3] = i / (sphere_positions.length / 3);
                pickColors[i * 3 + 1] = i / (sphere_positions.length / 3);
                pickColors[i * 3 + 2] = i / (sphere_positions.length / 3);
                // console.log(pickColors[i * 3], pickColors[i * 3 + 1], pickColors[i * 3 + 2]);
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphere_positions, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphere_colors, gl.STATIC_DRAW);

            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_sizeBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphere_sizes, gl.STATIC_DRAW);

            // 颜色缓冲区
            gl.bindBuffer(gl.ARRAY_BUFFER, pickColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, sphere_colors, gl.STATIC_DRAW);

            // 绘制
            draw();
        });

        function draw() {
            var cosTheta = Math.cos(rotation[0] / 180 * Math.PI);
            var sinTheta = Math.sin(rotation[0] / 180 * Math.PI);
            var cosPhi = Math.cos(rotation[1] / 180 * Math.PI);
            var sinPhi = Math.sin(rotation[1] / 180 * Math.PI);

            var rotationMatrix = new Float32Array([
                cosTheta, 0, sinTheta, 0,
                sinPhi * sinTheta, cosPhi, -sinPhi * cosTheta, 0,
                -cosPhi * sinTheta, sinPhi, cosPhi * cosTheta, 0,
                0, 0, 0, 1
            ]);
            
            gl.uniformMatrix4fv(rotationMatrixLocation, false, rotationMatrix);
            gl.uniform1f(gl.getUniformLocation(program, 'scale'), scale);

            gl.disable(gl.BLEND);
            
            // 在隐藏的帧缓冲区中渲染场景
            gl.bindFramebuffer(gl.FRAMEBUFFER, pickFramebuffer);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, pickColorBuffer);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, sphere_positions.length / 3);
            
            // 切换回默认的帧缓冲区
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            // 在默认的帧缓冲区中渲染场景
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // 设置适当的混合模式以实现半透明效果
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // 绘制球体
            gl.uniform1f(alphaLocation, sphere_alpha);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_colorBuffer);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(sizeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, sphere_sizeBuffer);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, sphere_positions.length / 3);

            // 绘制散点
            gl.uniform1f(alphaLocation, scatter_alpha);
            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_positionBuffer);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_colorBuffer);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(sizeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, scatter_sizeBuffer);
            gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, scatter_positions.length / 3);
            

        }
    })();
    </script>
</body>

</html>